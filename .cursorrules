# Dester Project Architecture & Conventions

## Project Overview
Dester is a Flutter application following **Clean Architecture** principles with **Riverpod** for state management, **GoRouter** for navigation, and **easy_localization** for internationalization.

## ⚠️ CRITICAL RULES - STRICT ENFORCEMENT

### Dependency Rules (NEVER VIOLATE)
1. **Domain layer MUST NEVER import from data or presentation layers**
2. **Presentation layer MUST NEVER import from data layer**
3. **Data layer MUST NEVER import from presentation layer**

### Factory Pattern Rules (NEVER VIOLATE)
1. **All feature factory methods MUST be static** (never instance methods)
2. **Providers MUST use static factory methods** (never instantiate feature classes)
3. **Screens MUST use use cases via providers** (never data sources directly)

### Validation Checklist
Before committing any code, verify:
- [ ] Domain layer has NO imports from `../data/` or `../presentation/`
- [ ] Presentation layer has NO imports from `../data/`
- [ ] Feature factories use ONLY static methods
- [ ] Providers call static factory methods
- [ ] All API models are mapped to domain entities

## Technology Stack
- **Flutter SDK**: ^3.10.0
- **State Management**: flutter_riverpod ^3.0.3
- **Navigation**: go_router ^17.0.0
- **Localization**: easy_localization ^3.0.8
- **Network**: dio ^5.9.0, connectivity_plus ^6.1.0
- **Storage**: shared_preferences ^2.3.3
- **API Client**: Custom lightweight client (no code generation)

## Project Structure

```
lib/
├── app/                              # App-level configuration
│   ├── localization/
│   │   └── app_localization.dart     # Localization keys constants
│   ├── providers/                    # App-wide Riverpod providers
│   │   └── connection_guard_provider.dart
│   └── router/
│       └── app_router.dart           # GoRouter configuration
│
├── core/                             # Shared/core functionality
│   ├── constants/
│   │   └── app_constants.dart
│   ├── errors/                       # Error handling
│   │   ├── errors.dart
│   │   ├── failures.dart
│   │   └── result.dart
│   ├── network/                      # Custom API client (no code generation!)
│   │   ├── dester_api.dart           # Main API facade
│   │   ├── api_client.dart           # Dio HTTP client wrapper
│   │   ├── api_exception.dart        # Exception handling
│   │   ├── api_provider.dart         # Global singleton
│   │   ├── api/                      # API endpoint implementations
│   │   │   ├── settings_api.dart
│   │   │   ├── library_api.dart
│   │   │   ├── scan_api.dart
│   │   │   ├── movies_api.dart
│   │   │   ├── tvshows_api.dart
│   │   │   ├── search_api.dart
│   │   │   └── health_api.dart
│   │   ├── models/                   # Simple DTOs (plain Dart, no codegen)
│   │   │   ├── api_response.dart
│   │   │   ├── settings_models.dart
│   │   │   ├── library_models.dart
│   │   │   ├── scan_models.dart
│   │   │   └── media_models.dart
│   │   └── mappers/                  # DTO to domain entity converters
│   │       └── settings_mapper.dart
│   ├── storage/
│   │   ├── preferences_service.dart  # SharedPreferences wrapper
│   │   └── storage_keys.dart         # Storage key constants
│   ├── theme/
│   │   ├── app_colors.dart
│   │   ├── app_text_styles.dart
│   │   └── app_theme.dart
│   ├── utils/                        # Utility classes
│   │   └── connection_helper.dart
│   └── widgets/                      # Shared/reusable widgets
│
└── features/                         # Feature modules (Clean Architecture)
    └── home/                         # Home feature (example)
        ├── home_feature.dart         # Dependency injection factory
        ├── data/
        │   ├── datasources/
        │   │   └── home_datasource.dart
        │   ├── mappers/
        │   │   ├── movie_mapper.dart
        │   │   └── tv_show_mapper.dart
        │   └── repository/
        │       └── home_repository_impl.dart
        ├── domain/
        │   ├── entities/
        │   │   ├── movie.dart
        │   │   └── tv_show.dart
        │   ├── repository/
        │   │   └── home_repository.dart
        │   └── usecases/
        │       ├── get_movies_list.dart
        │       ├── get_movies_list_impl.dart
        │       ├── get_tv_shows_list.dart
        │       └── get_tv_shows_list_impl.dart
        └── presentation/
            ├── controllers/
            │   └── home_controller.dart
            ├── screens/
            │   └── home_screen.dart
            └── widgets/
                ├── movie_card.dart
                └── tv_show_card.dart
```

## Clean Architecture Principles

### Layer Separation
1. **Domain Layer** (innermost, no dependencies)
   - Entities: Pure data classes
   - Repository Interfaces: Abstract contracts
   - Use Case Interfaces: Abstract business logic contracts
   - Use Case Implementations: Business logic implementations

2. **Data Layer** (depends on Domain)
   - Data Sources: External data access (API, local storage)
   - Repository Implementations: Implements domain repository interfaces
   - Mappers: Convert data models to domain entities

3. **Presentation Layer** (depends on Domain)
   - Controllers: State management (ChangeNotifier or Riverpod)
   - Screens: Page-level widgets
   - Widgets: Reusable UI components

### Dependency Rule (STRICT - NEVER VIOLATE)
- **Domain** ← **Data** (Data implements Domain interfaces)
- **Domain** ← **Presentation** (Presentation uses Domain entities/use cases)
- **Data** and **Presentation** are independent
- **Domain layer MUST NEVER import from data or presentation layers**
- **Presentation layer MUST NEVER import from data layer** (use domain layer only)
- **Data layer MUST NEVER import from presentation layer**

### Strict Import Rules
1. **Domain layer imports**: Only Dart SDK, Flutter framework, and other domain files
   - ❌ NEVER import from `../data/` or `../../data/`
   - ❌ NEVER import from `../presentation/` or `../../presentation/`
   - ❌ NEVER import data sources, repositories implementations, or presentation files
   
2. **Data layer imports**: Domain interfaces, data sources, mappers, external APIs
   - ✅ CAN import from domain layer (`../../domain/`)
   - ✅ CAN import data sources and mappers
   - ❌ NEVER import from presentation layer (`../presentation/`)
   
3. **Presentation layer imports**: Domain entities, use cases, UI framework
   - ✅ CAN import from domain layer (`../../domain/`)
   - ✅ CAN import other presentation files
   - ❌ NEVER import from data layer (`../../data/` or `../data/`)
   - ❌ NEVER import data sources, repository implementations, or mappers directly

## File Naming Conventions

### Use Cases
- **Interface**: `{use_case_name}.dart` (e.g., `check_connection.dart`)
- **Implementation**: `{use_case_name}_impl.dart` (e.g., `check_connection_impl.dart`)

### Repositories
- **Interface**: `{feature}_repository.dart` (in domain layer)
- **Implementation**: `{feature}_repository_impl.dart` (in data layer)

### Data Sources
- **Interface**: `{source}_data_source.dart`
- **Implementation**: `{source}_data_source_impl.dart`

### Features
- **Factory**: `{feature}_feature.dart` (dependency injection setup)

## Dependency Injection Pattern

**MANDATORY: All feature factories MUST use static methods (NOT instance methods)**

Each feature has a factory class that creates and wires dependencies. The factory class MUST:
1. Use ONLY static methods for creating dependencies
2. Follow the pattern: `static ReturnType createXxx()` or `static ReturnType createXxxUseCase()`
3. NEVER expose instance methods or getters
4. Wire dependencies: DataSource → Repository → UseCase

### Correct Pattern (✅ ALWAYS USE THIS)
```dart
class SettingsFeature {
  // Screen factories (static)
  static SettingsScreen createSettingsScreen() {
    return const SettingsScreen();
  }
  
  // Use case factories (static)
  static GetSettings createGetSettings() {
    final dataSource = SettingsDataSource();
    final repository = SettingsRepositoryImpl(dataSource: dataSource);
    return GetSettingsImpl(repository);
  }
  
  static UpdateSettings createUpdateSettings() {
    final dataSource = SettingsDataSource();
    final repository = SettingsRepositoryImpl(dataSource: dataSource);
    return UpdateSettingsImpl(repository);
  }
}
```

### Incorrect Pattern (❌ NEVER USE THIS)
```dart
class SettingsFeature {
  // ❌ WRONG: Instance methods
  GetSettings get getSettings {
    final dataSource = SettingsDataSource();
    final repository = SettingsRepositoryImpl(dataSource: dataSource);
    return GetSettingsImpl(repository);
  }
}
```

## State Management (Riverpod)

### Provider Types
- **NotifierProvider**: For stateful providers (Riverpod 3.0)
- **FutureProvider**: For async initialization
- **StateNotifierProvider**: Deprecated in Riverpod 3.0, use NotifierProvider

### Provider Location
- App-wide providers: `lib/app/providers/`
- Feature-specific providers: Can be in feature's presentation layer if needed

### Provider Pattern
```dart
final myProvider = NotifierProvider<MyNotifier, MyState>(
  MyNotifier.new,
);

class MyNotifier extends Notifier<MyState> {
  @override
  MyState build() {
    // Initialization
    return MyState.initial();
  }
}
```

### Use Case Provider Pattern (STRICT)
**MANDATORY: Providers MUST use static factory methods from feature classes**

```dart
// ✅ CORRECT: Use static factory methods
final getSettingsProvider = Provider<GetSettings>((ref) {
  return SettingsFeature.createGetSettings();
});

// ❌ WRONG: Creating feature instance
final getSettingsProvider = Provider<GetSettings>((ref) {
  return SettingsFeature().getSettings; // NEVER use instance methods
});
```

## Localization

### Structure
- Translation files: `assets/translations/{locale}.json`
- Keys helper: `lib/app/localization/app_localization.dart`

### Usage
```dart
// Using helper constants
Text(AppLocalization.appTitle.tr())

// Direct key
Text('app.title'.tr())
```

### Adding New Translations
1. Add key to `app_localization.dart`
2. Add translations to `en.json` and `es.json`
3. Use `{key}.tr()` in widgets

## Routing (GoRouter)

### Configuration
- Router config: `lib/app/router/app_router.dart`
- Routes defined using `GoRoute`
- Named routes for navigation

### Navigation
```dart
// Using route name
context.goNamed('home');

// Using path
context.go('/home');
```

## Connection Service (Core Infrastructure)

### Architecture
- **Location**: `lib/core/connection/` (infrastructure, not a feature)
- **Domain**: Connection status entities, repository interface, use cases
- **Data**: Network and preferences data sources, repository implementation
- **Presentation**: Modal/drawer widgets, Riverpod provider

### Platform Adaptation
- **Desktop** (Windows, Linux, macOS): Modal dialog
- **Mobile** (iOS, Android): Bottom drawer

### Usage
- Automatically monitors connection on app startup
- Shows modal/drawer on connection errors
- API URL stored in SharedPreferences
- Close button disabled when API is not connected

## Code Style Guidelines

### Imports Order
1. Dart SDK imports
2. Flutter imports
3. Package imports (third-party)
4. Project imports (relative)

### Widget Naming
- Screens: `{Feature}Screen` (e.g., `HomeScreen`)
- Widgets: `{Purpose}Widget` or descriptive name (e.g., `MovieCard`)
- Controllers: `{Feature}Controller` (e.g., `HomeController`)

### Class Naming
- Entities: Noun (e.g., `Movie`, `ConnectionGuardState`)
- Use Cases: Verb phrase (e.g., `CheckConnection`, `GetMoviesList`)
- Repositories: `{Feature}Repository` (interface), `{Feature}RepositoryImpl` (implementation)
- Data Sources: `{Source}DataSource` (interface), `{Source}DataSourceImpl` (implementation)

## Testing Structure (Future)

```
test/
├── features/
│   ├── connection/
│   │   ├── domain/
│   │   │   └── usecases/
│   │   └── data/
│   └── home/
└── core/
```

## Important Notes

1. **Always separate interface and implementation** for use cases
2. **Domain layer must never depend on other layers** (STRICT RULE)
3. **Presentation layer must never depend on data layer** (STRICT RULE)
4. **Use dependency injection factories** with static methods only (STRICT RULE)
5. **Riverpod providers** should be in `app/providers/` for app-wide state
6. **Platform-specific UI** should adapt based on `Platform.isDesktop` checks
7. **Localization keys** should be centralized in `app_localization.dart`
8. **Storage keys** should be in `storage_keys.dart` constants

## Clean Architecture Enforcement Rules

### ❌ CRITICAL VIOLATIONS (NEVER ALLOW)

1. **Presentation Layer Importing Data Layer**
   ```dart
   // ❌ NEVER DO THIS in presentation layer
   import '../../data/datasources/settings_datasource.dart';
   import '../../data/repository/settings_repository_impl.dart';
   
   // ✅ CORRECT: Use domain layer only
   import '../../domain/usecases/get_settings.dart';
   import '../../domain/entities/settings.dart';
   ```

2. **Domain Layer Importing External Layers**
   ```dart
   // ❌ NEVER DO THIS in domain layer
   import '../../data/repository/settings_repository_impl.dart';
   import '../../presentation/screens/settings_screen.dart';
   
   // ✅ CORRECT: Domain only imports domain or Dart/Flutter SDK
   import '../entities/settings.dart';
   import '../repository/settings_repository.dart';
   ```

3. **Instance Methods in Feature Factories**
   ```dart
   // ❌ NEVER DO THIS
   class SettingsFeature {
     GetSettings get getSettings { ... }
   }
   
   // ✅ CORRECT: Use static methods
   class SettingsFeature {
     static GetSettings createGetSettings() { ... }
   }
   ```

4. **Direct Data Source Usage in Presentation**
   ```dart
   // ❌ NEVER DO THIS in screens/controllers
   final dataSource = SettingsDataSource();
   await dataSource.getSettings();
   
   // ✅ CORRECT: Use use cases
   final getSettings = ref.read(getSettingsProvider);
   await getSettings();
   ```

### ✅ REQUIRED PATTERNS (ALWAYS FOLLOW)

1. **Feature Factory Pattern**
   - All methods MUST be static
   - Methods return use cases, screens, or other dependencies
   - Wire dependencies: DataSource → Repository → UseCase

2. **Use Case Provider Pattern**
   - Providers MUST call static factory methods
   - Providers return use case interfaces (not implementations)
   - Use in presentation layer via `ref.read()` or `ref.watch()`

3. **Repository Pattern**
   - Repository interface in domain layer
   - Repository implementation in data layer
   - Implementation MUST implement domain interface

4. **Mapper Pattern**
   - Always map API DTOs to domain entities
   - Core mappers in `core/network/mappers/` (for DTOs → domain)
   - Feature mappers in data layer (for domain-specific conversions)
   - Domain entities never contain DTO types

## Adding a New Feature

**MANDATORY CHECKLIST - Follow ALL steps in order:**

1. **Create feature folder**: `lib/features/{feature_name}/`

2. **Set up domain layer** (NO imports from data/presentation):
   - Create entities: `domain/entities/{entity}.dart`
   - Create repository interface: `domain/repository/{feature}_repository.dart`
   - Create use case interfaces: `domain/usecases/{use_case}.dart`
   - Create use case implementations: `domain/usecases/{use_case}_impl.dart`
   - ✅ VERIFY: Domain files only import from domain layer or Dart/Flutter SDK

3. **Set up data layer** (CAN import from domain, NEVER from presentation):
   - Create data sources: `data/datasources/{source}_datasource.dart`
     - Inject `DesterApi` via constructor: `MyDataSource(this._api)`
     - Use `ApiProvider.instance` in feature factories
   - Create mappers if needed: `data/mappers/{entity}_mapper.dart`
   - Create repository implementation: `data/repository/{feature}_repository_impl.dart`
   - ✅ VERIFY: Data files never import from presentation layer

4. **Set up presentation layer** (CAN import from domain, NEVER from data):
   - Create controllers: `presentation/controllers/{feature}_controller.dart`
   - Create screens: `presentation/screens/{feature}_screen.dart`
   - Create widgets: `presentation/widgets/{widget}.dart`
   - Create providers: `presentation/providers/{feature}_providers.dart`
   - ✅ VERIFY: Presentation files never import from data layer

5. **Create feature factory**: `{feature}_feature.dart`
   - ✅ ALL methods MUST be static
   - Create static factories for screens: `static ScreenName createScreenName()`
   - Create static factories for data sources: `static DataSource createDataSource()`
     - **MUST inject API**: `return MyDataSource(ApiProvider.instance)`
   - Create static factories for use cases: `static UseCaseName createUseCaseName()`
   - Wire dependencies: API → DataSource → Repository → UseCase

6. **Create providers** (if using Riverpod):
   - ✅ Use static factory methods: `SettingsFeature.createGetSettings()`
   - ✅ NEVER instantiate feature class: `SettingsFeature().getSettings`

7. **Add routes** in `app_router.dart`:
   - Use static factory methods: `SettingsFeature.createSettingsScreen()`

8. **Add translations** if needed

### Pre-Commit Validation Checklist
Before committing any feature code, verify:
- [ ] Domain layer has NO imports from data or presentation
- [ ] Presentation layer has NO imports from data layer
- [ ] Feature factory uses ONLY static methods
- [ ] Providers use static factory methods (not instance methods)
- [ ] All API models are mapped to domain entities
- [ ] Repository implementation implements domain interface

## Common Patterns

### Use Case Pattern
```dart
// Interface
abstract class MyUseCase {
  Future<Result> call(Params params);
}

// Implementation
class MyUseCaseImpl implements MyUseCase {
  final MyRepository repository;
  
  MyUseCaseImpl(this.repository);
  
  @override
  Future<Result> call(Params params) async {
    // Business logic
  }
}
```

### Repository Pattern
```dart
// Domain interface (domain layer)
abstract class MyRepository {
  Future<Entity> getData();
}

// Data implementation (data layer)
class MyRepositoryImpl implements MyRepository {
  final MyDataSource dataSource;
  
  MyRepositoryImpl({required this.dataSource});
  
  @override
  Future<Entity> getData() async {
    final apiModel = await dataSource.fetch();
    return EntityMapper.fromApiModel(apiModel); // Always map to domain entity
  }
}
```

### Settings Feature Example (Complete Pattern)
```dart
// 1. Domain Entity (domain/entities/settings.dart)
class Settings {
  final String? tmdbApiKey;
  final bool firstRun;
  const Settings({this.tmdbApiKey, required this.firstRun});
}

// 2. Repository Interface (domain/repository/settings_repository.dart)
abstract class SettingsRepository {
  Future<Settings> getSettings();
  Future<Settings> updateSettings({String? tmdbApiKey});
}

// 3. Use Case Interface (domain/usecases/get_settings.dart)
abstract class GetSettings {
  Future<Settings> call();
}

// 4. Use Case Implementation (domain/usecases/get_settings_impl.dart)
class GetSettingsImpl implements GetSettings {
  final SettingsRepository repository;
  GetSettingsImpl(this.repository);
  
  @override
  Future<Settings> call() async {
    return await repository.getSettings();
  }
}

// 5. Data Source (data/datasources/settings_datasource.dart)
class SettingsDataSource {
  final DesterApi _api;
  
  SettingsDataSource(this._api);
  
  Future<Result<Settings>> getSettings() async {
    try {
      final dto = await _api.settings.getSettings();
      final settings = SettingsApiMapper.toDomain(dto);
      return Success(settings);
    } on ApiException catch (e) {
      return ResultFailure(_apiExceptionToFailure(e));
    }
  }
}

// 6. Mapper (core/network/mappers/settings_mapper.dart)
class SettingsApiMapper {
  static Settings toDomain(SettingsDto dto) {
    return Settings(
      firstRun: dto.firstRun,
      scanSettings: dto.scanSettings != null
          ? _scanSettingsToDomain(dto.scanSettings!)
          : null,
    );
  }
}

// 7. Repository Implementation (data/repository/settings_repository_impl.dart)
class SettingsRepositoryImpl implements SettingsRepository {
  final SettingsDataSource dataSource;
  SettingsRepositoryImpl({required this.dataSource});
  
  @override
  Future<Result<Settings>> getSettings() async {
    // DataSource already returns domain entities
    return await dataSource.getSettings();
  }
}

// 8. Feature Factory (settings_feature.dart)
class SettingsFeature {
  static SettingsDataSource createSettingsDataSource() {
    return SettingsDataSource(ApiProvider.instance);
  }
  
  static GetSettings createGetSettings() {
    final dataSource = createSettingsDataSource();
    final repository = SettingsRepositoryImpl(dataSource: dataSource);
    return GetSettingsImpl(repository);
  }
}

// 9. Provider (presentation/providers/settings_providers.dart)
final getSettingsProvider = Provider<GetSettings>((ref) {
  return SettingsFeature.createGetSettings(); // Static method
});

// 10. Screen Usage (presentation/screens/settings_screen.dart)
final settingsProvider = FutureProvider<Settings>((ref) async {
  final getSettings = ref.watch(getSettingsProvider);
  return await getSettings(); // Use case, not data source
});
```

## API Client Architecture

### Custom Lightweight API Client (No Code Generation!)

**We use a simple, custom API client** - NOT auto-generated code. This provides better maintainability, smaller codebase, and easier debugging.

### Architecture Overview
```
lib/core/network/
├── dester_api.dart          # Main API facade - single entry point
├── api_client.dart          # Dio HTTP client wrapper
├── api_exception.dart       # Structured exception handling
├── api_provider.dart        # Global singleton for API instance
├── api/                     # Endpoint implementations (one per domain)
│   ├── settings_api.dart
│   ├── library_api.dart
│   ├── scan_api.dart
│   ├── movies_api.dart
│   ├── tvshows_api.dart
│   ├── search_api.dart
│   └── health_api.dart
├── models/                  # Simple DTOs (plain Dart classes)
│   ├── api_response.dart    # Generic response wrapper
│   ├── settings_models.dart
│   ├── library_models.dart
│   ├── scan_models.dart
│   └── media_models.dart
└── mappers/                 # Convert DTOs to domain entities
    └── settings_mapper.dart
```

### Usage Pattern

#### 1. Initialize API (happens automatically)
```dart
// Automatically initialized from saved URL
final api = ApiProvider.instance;

// Or manually initialize
ApiProvider.initialize('http://localhost:3000');

// Switch servers
ApiProvider.updateBaseUrl('http://new-server:3000');
```

#### 2. Use API in DataSources
```dart
class MyDataSource {
  final DesterApi _api;
  
  MyDataSource(this._api);
  
  Future<Result<MyEntity>> getData() async {
    try {
      final dto = await _api.movies.getMovies();
      final entity = MyMapper.toDomain(dto);
      return Success(entity);
    } on ApiException catch (e) {
      return ResultFailure(_apiExceptionToFailure(e));
    }
  }
}
```

#### 3. Wire in Feature Factories
```dart
class MyFeature {
  static MyDataSource createDataSource() {
    return MyDataSource(ApiProvider.instance);
  }
}
```

### API Client Models (DTOs)

**Simple plain Dart classes** - no code generation needed!

```dart
// Example DTO
class SettingsDto {
  final int port;
  final bool firstRun;
  
  const SettingsDto({required this.port, required this.firstRun});
  
  factory SettingsDto.fromJson(Map<String, dynamic> json) {
    return SettingsDto(
      port: json['port'] as int,
      firstRun: json['firstRun'] as bool,
    );
  }
  
  Map<String, dynamic> toJson() => {
    'port': port,
    'firstRun': firstRun,
  };
}
```

### Exception Handling

The API client provides structured exceptions:

```dart
try {
  final data = await api.settings.getSettings();
} on NetworkException catch (e) {
  // No internet connection
} on BadRequestException catch (e) {
  // Validation error (400)
} on UnauthorizedException catch (e) {
  // Auth error (401)
} on NotFoundException catch (e) {
  // Not found (404)
} on ServerException catch (e) {
  // Server error (500)
} on ApiException catch (e) {
  // Other API errors
}
```

### Adding New API Endpoints

**Simple 3-step process:**

1. **Create DTO models** in `models/`
2. **Create API class** in `api/`
3. **Add to DesterApi** class

No code generation, no build_runner, no complexity!

### Benefits of Custom Client
- ✅ **Simple**: Plain Dart classes, easy to understand
- ✅ **Fast**: No build step required
- ✅ **Maintainable**: ~2,000 lines vs 67MB generated
- ✅ **Debuggable**: No generated code to wade through
- ✅ **Type-safe**: Full compile-time checking
- ✅ **Flexible**: Easy to customize and extend

